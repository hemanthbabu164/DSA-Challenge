//*Word Search , A fun question
//M1:Recursion , General thinking and might be a good answer
class Solution {
public:
    bool wordSearch(int i, int j, int n, int m, vector<vector<char>>& board, string word,string s,vector<vector<bool>> &visited){
        if(word==s){
            return true;
        }
        if(i<0 || i>=n || j<0 || j>=m){
            return false;
        }
        if(visited[i][j]){
            return false;
        }
        if(word[s.size()]==board[i][j]){
            string temp=s;
            s+=word[s.size()];
            visited[i][j]=true;
            if(wordSearch(i+1,j,n,m,board,word,s,visited)){
                return true;
            }            
            if(wordSearch(i-1,j,n,m,board,word,s,visited)){
                return true;
            }
            if(wordSearch(i,j+1,n,m,board,word,s,visited)){
                return true;
            }
            if(wordSearch(i,j-1,n,m,board,word,s,visited)){
                return true;
            }
            s=temp;
            
            visited[i][j]=false;
            
        }
        return false;
    }
    bool exist(vector<vector<char>>& board, string word) {
        int n=board.size();
        int m=board[0].size();
        vector<vector<bool>> visited(n, vector<bool>(m, false));
        for(int i=0;i<n;i++){
            for(int j=0;j<m;j++){
                if(wordSearch(i,j,n,m,board,word,"",visited)){
                    return true;
                }
            }
        }
        return false;
    }
};

//N-Queens, aint this a Queen in questions
class Solution {
public:
    bool is_possible(int row, int col,int n,vector<string> &board){
        //Since we are going from left to right while inserting Queens,
        //we just need to check the presence of queen in the left attacking positions
        int i=row;
        int j=col;
        while(i>=0 && j>=0){
            if(board[i][j]=='Q') return false;
            i--;
            j--;
        }
        i=row;
        j=col;
        while(i<n && j>=0){
            if(board[i][j]=='Q') return false;
            i++;
            j--;
        }
        for(j=col-1;j>=0;j--){
            if(board[row][j]=='Q') return false;
        }
        return true;
    }
    void nQueen(int col,int n,vector<vector<string>> &ans,vector<string> &board ){
        if(col==n){
            ans.push_back(board);
        }
        for(int row=0;row<n;row++){
            if(is_possible(row,col,n,board)){
                board[row][col]='Q';
                nQueen(col+1,n,ans,board);
                board[row][col]='.';
            }
        }
    }
    vector<vector<string>> solveNQueens(int n) {
        vector<vector<string>> ans;
        vector<string> board(n,string(n,'.'));
        nQueen(0,n,ans,board);
        return ans;

    }
};

//*RatMaze
//A fun Question just like the above N-Queens
class Solution {
  public:
    void ratMaze(int i, int j, int n, vector<vector<int>> &mat,vector<string> &ans, string path){
        if(i==n-1 && j==n-1){
            ans.push_back(path);
            return;
        }
        mat[i][j]=0;
        //Down
        if(i+1<n && mat[i+1][j]==1){
            ratMaze(i+1,j,n,mat,ans,path+'D');
        }
        //Up
        if(i-1>=0 && mat[i-1][j]==1){
            ratMaze(i-1,j,n,mat,ans,path+'U');
        }
        //Left
        if(j-1>=0 && mat[i][j-1]==1){
            ratMaze(i,j-1,n,mat,ans,path+'L');
        }
        //Right
        if(j+1<n && mat[i][j+1]==1){
            ratMaze(i,j+1,n,mat,ans,path+'R');
        }
        mat[i][j]=1;
    }
    vector<string> findPath(vector<vector<int>> &mat) {
        // Your code goes here
        string path="";
        vector<string> ans;
        if(mat[0][0]==0) return ans;
        int n=mat.size();
        ratMaze(0,0,n,mat,ans,path);
        return ans;
    }
};
