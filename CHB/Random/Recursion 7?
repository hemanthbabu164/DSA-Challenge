//* Map Coloring
class Solution{
public:
    // Function to determine if graph can be coloured with at most M colours such
    // that no two adjacent vertices of graph are coloured with same colour.
    bool genPaths(int i, int n,int m, vector<int> &color, bool graph[101][101]){
        if(i==n){return true;}
        
        for(int k=1;k<=m;k++){
            bool key=true;
            for(int l=0;l<n;l++){
                if(graph[i][l] && color[l]==k){
                    key=false;
                    break;
                }
            }
            if(key){
                color[i]=k;
                if(genPaths(i+1,n,m,color,graph)){
                    return true;
                }
            }
            
        }
        return false;
    }
    bool graphColoring(bool graph[101][101], int m, int n) {
        // your code here
        //m=no.of colors,n no.of nodes
        //graph contains edges, i.e., if graph[0][1]=true, then there is an edge between them
        vector<int> color(n,0);
        
        return genPaths(0,n,m,color,graph);
    }
};

//*Sudoku Solver
//M1: Recursion ,Will Be TLE if YOU MISS THE RETURN FALSE after checking all ten possibilities of the position.
class Solution {
public:
    bool is_possible(int row,int col, char ch, vector<vector<char>> &board){
        for(int i=0;i<9;i++){
            if(board[row][i]==ch){
                return false;
            }
            if(board[i][col]==ch){
                return false;
            }
            //Submatrix, 3*(ind/3)[as it is int we get 0 or 3 or 6] 
            //i/3=>(0,0,0,1,1,1,2,2,2) i%3=>(0,1,2,0,1,2,0,1,2)
            if(board[3*(row/3)+i/3][3*(col/3)+i%3]==ch){
                return false;
            }
        }
        return true;
    }
    bool solve(vector<vector<char>> &board){
        for(int i=0;i<9;i++){
            for(int j=0;j<9;j++){
                if(board[i][j]=='.'){
                    for(char ch='1';ch<='9';ch++){
                        if(is_possible(i,j,ch,board)){
                            board[i][j]=ch;
                            if(solve(board)){
                                return true;
                            }
                            board[i][j]='.';
                        }
                    }
                    return false;
                }
            }
        }
        return true;//this one executes only when all the board is filled, 
                    //its the final and it should be true
    }
    void solveSudoku(vector<vector<char>>& board) {
        bool key=solve(board);
    }
};
